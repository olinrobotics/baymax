import unittest

class TestPleasantnessCalculation(unittest.TestCase):
    def setUp(self):
        self.thresholds = [.25, .5, .75]
        self.p = Pleasantness()

    def test_very_low(self):
        pos = self.thresholds[0] - .01
        pleasantness = self.p.calculate(pos, self.thresholds)
        self.assertTrue(pleasantness == 'very low')

    def test_low(self):
        '''edgecase should round up to low'''
        pos = self.thresholds[0]
        pleasantness = self.p.calculate(pos, self.thresholds)
        self.assertTrue(pleasantness == 'low')

    def test_high(self):
        pos = self.thresholds[1]
        pleasantness = self.p.calculate(pos, self.thresholds)
        self.assertTrue(pleasantness == 'high')

    def test_very_high(self):
        pos = self.thresholds[2]
        pleasantness = self.p.calculate(pos, self.thresholds)
        self.assertTrue(pleasantness == 'very high')


class Pleasantness:
    def __init__(self):
        pass

    def calculate(self, pos, thresholds):
        '''calculates pleasantness based on the inputs of
        positivity (a number generated by nltk sentiment
        analysis), and threshold (a list of the form
        [low_thres, thres, high_thres])'''
        # threshold between very low and low
        low_thres = thresholds[0]
        # threshold between low and high
        thres = thresholds[1]
        # threshold between high and very highfrom em_r_novelty import
        high_thres = thresholds[2]

        # return pleasantness status based on pos and thresholds
        if pos >= thres:
            if pos >= high_thres:
                return 'very high'
            else:
                return 'high'
        elif pos < thres:
            if pos >= low_thres:
                return 'low'
            else:
                return 'very low'
        return pleasantness


class Goal_Relevance:
    def __init__(self):
        pass

    def code(self, em_profile):
        pass

if __name__ == '__main__':
    unittest.main()
